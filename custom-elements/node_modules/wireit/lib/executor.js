/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import { NoCommandScriptExecution } from './execution/no-command.js';
import { StandardScriptExecution } from './execution/standard.js';
import { ServiceScriptExecution } from './execution/service.js';
import { scriptReferenceToString } from './config.js';
import { Deferred } from './util/deferred.js';
let executorConstructorHook;
/**
 * For GC testing only. A function that is called whenever an Executor is
 * constructed.
 */
export function registerExecutorConstructorHook(fn) {
    executorConstructorHook = fn;
}
/**
 * Executes a script that has been analyzed and validated by the Analyzer.
 */
export class Executor {
    constructor(rootConfig, logger, workerPool, cache, failureMode, previousIterationServices, isWatchMode) {
        this._executions = new Map();
        this._persistentServices = new Map();
        this._ephemeralServices = [];
        /** Resolves when the first failure occurs in any script. */
        this._failureOccured = new Deferred();
        /** Resolves when we decide that new scripts should not be started. */
        this._stopStartingNewScripts = new Deferred();
        /** Resolves when we decide that running scripts should be killed. */
        this._killRunningScripts = new Deferred();
        /** Resolves when we decide that services should be stopped. */
        this._stopServices = new Deferred();
        executorConstructorHook?.(this);
        this._rootConfig = rootConfig;
        this._logger = logger;
        this._workerPool = workerPool;
        this._cache = cache;
        this._previousIterationServices = previousIterationServices;
        this._isWatchMode = isWatchMode;
        // If a failure occurs, then whether we stop starting new scripts or kill
        // running ones depends on the failure mode setting.
        void this._failureOccured.promise.then(() => {
            switch (failureMode) {
                case 'continue': {
                    if (!this._isWatchMode) {
                        this._stopServices.resolve();
                    }
                    break;
                }
                case 'no-new': {
                    this._stopStartingNewScripts.resolve();
                    if (!this._isWatchMode) {
                        this._stopServices.resolve();
                    }
                    break;
                }
                case 'kill': {
                    this._stopStartingNewScripts.resolve();
                    this._killRunningScripts.resolve();
                    this._stopServices.resolve();
                    break;
                }
                default: {
                    const never = failureMode;
                    throw new Error(`Internal error: unexpected failure mode: ${String(never)}`);
                }
            }
        });
    }
    /**
     * If this entire execution is aborted because e.g. the user sent a SIGINT to
     * the Wireit process, then dont start new scripts, and kill running ones.
     */
    abort() {
        this._stopStartingNewScripts.resolve();
        this._killRunningScripts.resolve();
        this._stopServices.resolve();
        if (this._previousIterationServices !== undefined) {
            for (const service of this._previousIterationServices.values()) {
                void service.abort();
            }
        }
    }
    /**
     * Execute the root script.
     */
    async execute() {
        if (this._previousIterationServices !== undefined &&
            this._previousIterationServices.size > 0) {
            // If any services were removed from the graph entirely, or used to be
            // persistent but are no longer, then stop them now.
            const currentPersistentServices = new Set();
            for (const script of findAllScripts(this._rootConfig)) {
                if (script.service && script.isPersistent) {
                    currentPersistentServices.add(scriptReferenceToString(script));
                }
            }
            const abortPromises = [];
            for (const [key, service] of this._previousIterationServices) {
                if (!currentPersistentServices.has(key)) {
                    abortPromises.push(service.abort());
                    this._previousIterationServices.delete(key);
                }
            }
            await Promise.all(abortPromises);
        }
        const errors = [];
        const rootExecutionResult = await this.getExecution(this._rootConfig).execute();
        if (!rootExecutionResult.ok) {
            errors.push(...rootExecutionResult.error);
        }
        // Wait for all persistent services to start.
        for (const service of this._persistentServices.values()) {
            // Persistent services start automatically, so calling start() here should
            // be a no-op, but it lets us get the started promise.
            const result = await service.start();
            if (!result.ok) {
                errors.push(result.error);
            }
        }
        // Wait for all ephemeral services to have terminated (either started and
        // stopped, or never needed to start).
        const ephemeralServiceResults = await Promise.all(this._ephemeralServices.map((service) => service.terminated));
        for (const result of ephemeralServiceResults) {
            if (!result.ok) {
                errors.push(result.error);
            }
        }
        // All previous services are either now adopted or stopped. Remove the
        // reference to this map to allow for garbage collection, otherwise in watch
        // mode we'll have a chain of references all the way back through every
        // iteration.
        this._previousIterationServices = undefined;
        return {
            persistentServices: this._persistentServices,
            errors,
        };
    }
    /**
     * Signal that a script has failed, which will potentially stop starting or
     * kill other scripts depending on the {@link FailureMode}.
     *
     * This method will be called automatically in the normal flow of execution,
     * but scripts can also call it directly to synchronously signal a failure.
     */
    notifyFailure() {
        this._failureOccured.resolve();
    }
    /**
     * Synchronously check if new scripts should stop being started.
     */
    get shouldStopStartingNewScripts() {
        return this._stopStartingNewScripts.settled;
    }
    /**
     * A promise which resolves if we should kill running scripts.
     */
    get shouldKillRunningScripts() {
        return this._killRunningScripts.promise;
    }
    /**
     * Get the execution instance for a script config, creating one if it doesn't
     * already exist.
     */
    getExecution(config) {
        const key = scriptReferenceToString(config);
        let execution = this._executions.get(key);
        if (execution === undefined) {
            if (config.command === undefined) {
                execution = new NoCommandScriptExecution(config, this, this._logger);
            }
            else if (config.service !== undefined) {
                execution = new ServiceScriptExecution(config, this, this._logger, this._stopServices.promise, this._previousIterationServices?.get(key), this._isWatchMode);
                if (config.isPersistent) {
                    this._persistentServices.set(key, execution);
                }
                else {
                    this._ephemeralServices.push(execution);
                }
            }
            else {
                execution = new StandardScriptExecution(config, this, this._workerPool, this._cache, this._logger);
            }
            this._executions.set(key, execution);
        }
        // Cast needed because our Map type doesn't know about the config ->
        // execution type guarantees. We could make a smarter Map type, but not
        // really worth it here.
        return execution;
    }
}
/**
 * Walk the dependencies of the given root script and return all scripts in the
 * graph (including the root itself).
 */
function findAllScripts(root) {
    const visited = new Set();
    const stack = [root];
    while (stack.length > 0) {
        const next = stack.pop();
        visited.add(next);
        for (const dep of next.dependencies) {
            if (!visited.has(dep.config)) {
                stack.push(dep.config);
            }
        }
    }
    return visited;
}
//# sourceMappingURL=executor.js.map