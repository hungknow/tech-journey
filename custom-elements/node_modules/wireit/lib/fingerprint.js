/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import { createHash } from 'crypto';
import { createReadStream } from 'fs';
import { glob } from './util/glob.js';
import { scriptReferenceToString } from './config.js';
/**
 * The fingerprint of a script. Converts lazily between string and data object
 * forms.
 */
export class Fingerprint {
    static fromString(string) {
        const fingerprint = new Fingerprint();
        fingerprint._str = string;
        return fingerprint;
    }
    /**
     * Generate the fingerprint data object for a script based on its current
     * configuration, input files, and the fingerprints of its dependencies.
     */
    static async compute(script, dependencyFingerprints) {
        let allDependenciesAreFullyTracked = true;
        const filteredDependencyFingerprints = [];
        for (const [dep, depFingerprint] of dependencyFingerprints) {
            if (!dep.cascade) {
                // cascade: false means the fingerprint of the dependency isn't
                // directly inherited.
                continue;
            }
            if (!depFingerprint.data.fullyTracked) {
                allDependenciesAreFullyTracked = false;
            }
            filteredDependencyFingerprints.push([
                scriptReferenceToString(dep.config),
                depFingerprint.hash,
            ]);
        }
        let fileHashes;
        if (script.files?.values.length) {
            const files = await glob(script.files.values, {
                cwd: script.packageDir,
                followSymlinks: true,
                // TODO(aomarks) This means that empty directories are not reflected in
                // the fingerprint, however an empty directory could modify the behavior
                // of a script. We should probably include empty directories; we'll just
                // need special handling when we compute the fingerprint, because there
                // is no hash we can compute.
                includeDirectories: false,
                // We must expand directories here, because we need the complete
                // explicit list of files to hash.
                expandDirectories: true,
                throwIfOutsideCwd: false,
            });
            // TODO(aomarks) Instead of reading and hashing every input file on every
            // build, use inode/mtime/ctime/size metadata (which is much faster to
            // read) as a heuristic to detect files that have likely changed, and
            // otherwise re-use cached hashes that we store in e.g.
            // ".wireit/<script>/hashes".
            fileHashes = await Promise.all(files.map(async (file) => {
                const absolutePath = file.path;
                const hash = createHash('sha256');
                for await (const chunk of createReadStream(absolutePath)) {
                    hash.update(chunk);
                }
                return [file.path, hash.digest('hex')];
            }));
        }
        else {
            fileHashes = [];
        }
        const fullyTracked = 
        // If any any dependency is not fully tracked, then we can't be either,
        // because we can't know if there was an undeclared input that this script
        // depends on.
        allDependenciesAreFullyTracked &&
            // A no-command script. Doesn't ever do anything itsef, so always fully
            // tracked.
            (script.command === undefined ||
                // A service. Fully tracked if we know its inputs. Can't produce output.
                (script.service !== undefined && script.files !== undefined) ||
                // A standard script. Fully tracked if we know both its inputs and
                // outputs.
                (script.files !== undefined && script.output !== undefined));
        const fingerprint = new Fingerprint();
        // Note: The order of all fields is important so that we can do fast string
        // comparison.
        const data = {
            fullyTracked,
            platform: process.platform,
            arch: process.arch,
            nodeVersion: process.version,
            command: script.command?.value,
            extraArgs: script.extraArgs ?? [],
            clean: script.clean,
            files: Object.fromEntries(fileHashes.sort(([aFile], [bFile]) => aFile.localeCompare(bFile))),
            output: script.output?.values ?? [],
            dependencies: Object.fromEntries(filteredDependencyFingerprints.sort(([aRef], [bRef]) => aRef.localeCompare(bRef))),
            service: script.service === undefined
                ? undefined
                : {
                    readyWhen: {
                        lineMatches: script.service.readyWhen.lineMatches?.toString(),
                    },
                },
            env: script.env,
        };
        fingerprint._data = data;
        return fingerprint;
    }
    get string() {
        if (this._str === undefined) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this._str = JSON.stringify(this._data);
        }
        return this._str;
    }
    get data() {
        if (this._data === undefined) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this._data = JSON.parse(this._str);
        }
        return this._data;
    }
    get hash() {
        if (this._hash === undefined) {
            this._hash = createHash('sha256')
                .update(this.string)
                .digest('hex');
        }
        return this._hash;
    }
    equal(other) {
        return this.string === other.string;
    }
}
//# sourceMappingURL=fingerprint.js.map