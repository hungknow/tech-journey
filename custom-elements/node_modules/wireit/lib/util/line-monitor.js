/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import { Deferred } from './deferred.js';
/**
 * Monitors the stdout and stderr of a child process line-by-line searching for
 * a match of the given regular expression.
 *
 * Note we can't use readline here because we want to check lines that haven't
 * completed yet.
 */
export class LineMonitor {
    constructor(child, pattern) {
        this._matched = new Deferred();
        this._stdout = '';
        this._stderr = '';
        /**
         * Resolves to `{"ok": true}` when a match was found or `{"ok": false}` when
         * this monitor was aborted.
         */
        this.matched = this._matched.promise;
        this._onStdout = (data) => {
            this._stdout = this._check(this._stdout + String(data));
        };
        this._onStderr = (data) => {
            this._stderr = this._check(this._stderr + String(data));
        };
        this._child = child;
        this._pattern = pattern;
        child.stdout.on('data', this._onStdout);
        child.stderr.on('data', this._onStderr);
    }
    abort() {
        this._removeEventListeners();
        this._matched.resolve({ ok: false, error: undefined });
    }
    _removeEventListeners() {
        this._child.stdout.removeListener('data', this._onStdout);
        this._child.stderr.removeListener('data', this._onStderr);
    }
    _check(buffer) {
        const lines = buffer.split(/\n/g);
        let end = 0;
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            if (i !== lines.length - 1) {
                // Don't move beyond the final line, since it might be incomplete, and
                // we want to match the entire line the next time _check is called.
                end += line.length + 1;
            }
            if (this._pattern.test(line)) {
                this._removeEventListeners();
                this._matched.resolve({ ok: true, value: undefined });
                break;
            }
        }
        return buffer.slice(end);
    }
}
//# sourceMappingURL=line-monitor.js.map