/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import chokidar from 'chokidar';
import { Analyzer } from './analyzer.js';
import { Executor } from './executor.js';
import { Deferred } from './util/deferred.js';
import { scriptReferenceToString, } from './config.js';
function unknownState(state) {
    return new Error(`Unknown watcher state ${String(state)}`);
}
function unexpectedState(state) {
    return new Error(`Unexpected watcher state ${state}`);
}
/**
 * The minimum time that must elapse after the last file change was detected
 * before we begin a new run. Also the minimum time between successive runs.
 *
 * Note even 0 is a useful value here, because that defers new runs to the next
 * JS task. This is important because if multiple scripts are watching the same
 * file that changed, we get a file watcher event for each of them. Without
 * debouncing, a second run will be immediately queued after the first event
 * starts the run.
 */
const DEBOUNCE_MS = 0;
/**
 * Watches a script for changes in its input files, and in the input files of
 * its transitive dependencies, and executes all affected scripts when they
 * change.
 *
 * Also watches all related package.json files and reloads script configuration
 * when they change.
 */
export class Watcher {
    constructor(rootScript, extraArgs, logger, workerPool, cache, failureMode, agent) {
        /** See {@link WatcherState} */
        this._state = 'initial';
        this._debounceTimeoutId = undefined;
        this._previousIterationServices = undefined;
        /**
         * File watchers for the input files of all scripts in this build graph.
         */
        this._inputFileWatchers = new Map();
        /**
         * Resolves when this watcher has been aborted and the last run finished.
         */
        this._finished = new Deferred();
        this._onConfigFileChanged = () => {
            this._latestRootScriptConfig = undefined;
            this._fileChanged();
        };
        this._fileChanged = () => {
            switch (this._state) {
                case 'watching': {
                    this._state = 'debouncing';
                    void this._startDebounce();
                    return;
                }
                case 'debouncing': {
                    void this._cancelDebounce();
                    void this._startDebounce();
                    return;
                }
                case 'running': {
                    this._state = 'queued';
                    return;
                }
                case 'queued':
                case 'aborted': {
                    return;
                }
                case 'initial': {
                    throw unexpectedState(this._state);
                }
                default: {
                    throw unknownState(this._state);
                }
            }
        };
        this._rootScript = rootScript;
        this._extraArgs = extraArgs;
        this._logger = logger;
        this._workerPool = workerPool;
        this._failureMode = failureMode;
        this._cache = cache;
        this._agent = agent;
    }
    watch() {
        void this._startRun();
        return this._finished.promise;
    }
    _startDebounce() {
        if (this._debounceTimeoutId !== undefined) {
            throw new Error('Expected #debounceTimeoutId to be undefined');
        }
        this._debounceTimeoutId = setTimeout(() => {
            this._onDebounced();
        }, DEBOUNCE_MS);
    }
    _cancelDebounce() {
        clearTimeout(this._debounceTimeoutId);
        this._debounceTimeoutId = undefined;
    }
    _onDebounced() {
        switch (this._state) {
            case 'debouncing': {
                this._debounceTimeoutId = undefined;
                this._startRun();
                return;
            }
            case 'initial':
            case 'watching':
            case 'queued':
            case 'running':
            case 'aborted': {
                throw unexpectedState(this._state);
            }
            default: {
                throw unknownState(this._state);
            }
        }
    }
    _startRun() {
        switch (this._state) {
            case 'initial':
            case 'debouncing': {
                this._state = 'running';
                this._logger.log({
                    script: this._rootScript,
                    type: 'info',
                    detail: 'watch-run-start',
                });
                if (this._latestRootScriptConfig === undefined) {
                    void this._analyze();
                }
                else {
                    void this._execute(this._latestRootScriptConfig);
                }
                return;
            }
            case 'watching':
            case 'queued':
            case 'running':
            case 'aborted': {
                throw unexpectedState(this._state);
            }
            default: {
                throw unknownState(this._state);
            }
        }
    }
    async _analyze() {
        if (this._state !== 'running') {
            throw unexpectedState(this._state);
        }
        const analyzer = new Analyzer(this._agent);
        const result = await analyzer.analyze(this._rootScript, this._extraArgs);
        if (this._state === 'aborted') {
            return;
        }
        // Set up watchers for all relevant config files even if there were errors
        // so that we'll try again when the user modifies a config file.
        const configFiles = [...result.relevantConfigFilePaths];
        // Order doesn't matter because we know we don't have any !negated patterns,
        // but we're going to compare arrays exactly so the order should be
        // deterministic.
        configFiles.sort();
        const oldWatcher = this._configFilesWatcher;
        if (!watchPathsEqual(configFiles, oldWatcher?.patterns)) {
            this._configFilesWatcher = makeWatcher(configFiles, '/', this._onConfigFileChanged);
            if (oldWatcher !== undefined) {
                void oldWatcher.watcher.close();
            }
        }
        if (!result.config.ok) {
            for (const error of result.config.error) {
                this._logger.log(error);
            }
            this._onRunDone();
            return;
        }
        this._latestRootScriptConfig = result.config.value;
        this._synchronizeInputFileWatchers(this._latestRootScriptConfig);
        void this._execute(this._latestRootScriptConfig);
    }
    async _execute(script) {
        if (this._state !== 'running') {
            throw unexpectedState(this._state);
        }
        this._executor = new Executor(script, this._logger, this._workerPool, this._cache, this._failureMode, this._previousIterationServices, true);
        const result = await this._executor.execute();
        this._previousIterationServices = result.persistentServices;
        for (const error of result.errors) {
            this._logger.log(error);
        }
        this._onRunDone();
    }
    _onRunDone() {
        this._logger.log({
            script: this._rootScript,
            type: 'info',
            detail: 'watch-run-end',
        });
        switch (this._state) {
            case 'queued': {
                // Note that the debounce time could actually have already elapsed since
                // the last file change while we were running, but we don't start the
                // debounce timer until the run finishes. This means that the debounce
                // interval is also the minimum time between successive runs. This seems
                // fine and probably good, and is simpler than maintaining a separate
                // "queued-debouncing" state.
                this._state = 'debouncing';
                void this._startDebounce();
                return;
            }
            case 'running': {
                this._state = 'watching';
                return;
            }
            case 'aborted': {
                this._finished.resolve();
                return;
            }
            case 'initial':
            case 'watching':
            case 'debouncing': {
                throw unexpectedState(this._state);
            }
            default: {
                throw unknownState(this._state);
            }
        }
    }
    _synchronizeInputFileWatchers(root) {
        const visited = new Set();
        const visit = (script) => {
            const key = scriptReferenceToString(script);
            if (visited.has(key)) {
                return;
            }
            visited.add(key);
            const newInputFiles = script.files?.values;
            const oldWatcher = this._inputFileWatchers.get(key);
            if (!watchPathsEqual(newInputFiles, oldWatcher?.patterns)) {
                if (newInputFiles === undefined || newInputFiles.length === 0) {
                    this._inputFileWatchers.delete(key);
                }
                else {
                    const newWatcher = makeWatcher(newInputFiles, script.packageDir, this._fileChanged);
                    this._inputFileWatchers.set(key, newWatcher);
                }
                if (oldWatcher !== undefined) {
                    void oldWatcher.watcher.close();
                }
            }
            for (const dep of script.dependencies) {
                visit(dep.config);
            }
        };
        visit(root);
        // There also could be some scripts that have been removed entirely.
        for (const [oldKey, oldWatcher] of this._inputFileWatchers) {
            if (!visited.has(oldKey)) {
                void oldWatcher.watcher.close();
                this._inputFileWatchers.delete(oldKey);
            }
        }
    }
    abort() {
        if (this._executor !== undefined) {
            this._executor.abort();
            this._executor = undefined;
        }
        switch (this._state) {
            case 'debouncing':
            case 'watching': {
                if (this._state === 'debouncing') {
                    this._cancelDebounce();
                }
                this._state = 'aborted';
                this._closeAllFileWatchers();
                this._finished.resolve();
                return;
            }
            case 'running':
            case 'queued': {
                this._state = 'aborted';
                this._closeAllFileWatchers();
                // Don't resolve #finished immediately so that we will wait for #analyze
                // or #execute to finish.
                return;
            }
            case 'aborted': {
                return;
            }
            case 'initial': {
                throw unexpectedState(this._state);
            }
            default: {
                throw unknownState(this._state);
            }
        }
    }
    _closeAllFileWatchers() {
        void this._configFilesWatcher?.watcher.close();
        for (const value of this._inputFileWatchers.values()) {
            void value.watcher.close();
        }
    }
}
const watchPathsEqual = (a, b) => {
    if (a === undefined && b === undefined) {
        return true;
    }
    if (a === undefined || b === undefined) {
        return false;
    }
    if (a.length !== b.length) {
        return false;
    }
    for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
};
/**
 * Exported for testing.
 *
 * @param ignoreInitial Ignore the initial "add" events emitted when chokidar
 * first discovers each file. We already do an initial run, so these events are
 * just noise that may trigger an unnecessary second run.
 * https://github.com/paulmillr/chokidar#path-filtering
 */
export const makeWatcher = (patterns, cwd, callback, ignoreInitial = true) => {
    // TODO(aomarks) chokidar doesn't work exactly like fast-glob, so there are
    // currently various differences in what gets watched vs what actually affects
    // the build. See https://github.com/google/wireit/issues/550.
    const watcher = chokidar.watch(
    // Trim leading slashes from patterns, to "re-root" all paths to the package
    // directory, just as we do when globbing for script execution.
    patterns.map((pattern) => pattern.replace(/^\/+/, '')), {
        cwd,
        ignoreInitial,
    });
    watcher.on('all', callback);
    return {
        patterns,
        watcher,
    };
};
//# sourceMappingURL=watcher.js.map