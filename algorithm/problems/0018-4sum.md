# 0018 4Sum

## Problem Description

Given an array `nums` of `n` integers, return an array of all the unique quadruplets `[nums[a], nums[b], nums[c], nums[d]]` such that:

- `0 <= a, b, c, d < n`
- `a`, `b`, `c`, and `d` are distinct.
- `nums[a] + nums[b] + nums[c] + nums[d] == target`

You may return the answer in any order. The solution set must not contain duplicate quadruplets.

### Example 1:
```
Input: nums = [1,0,-1,0,-2,2], target = 0
Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
```

### Example 2:
```
Input: nums = [2,2,2,2,2], target = 8
Output: [[2,2,2,2]]
```

## Two Pointers Approach

This problem is an extension of 3Sum. We can use a nested loop approach with two pointers to solve it efficiently.

### Algorithm Steps:

1. Sort the input array `nums`
2. Initialize an empty result array
3. Iterate through the array with index `i` from 0 to n-4
   - Skip duplicate values of `nums[i]` to avoid duplicate quadruplets
   - Iterate through the array with index `j` from i+1 to n-3
     - Skip duplicate values of `nums[j]` to avoid duplicate quadruplets
     - Use two pointers `left = j+1` and `right = n-1` to find pairs that sum to `target - nums[i] - nums[j]`
     - If sum is less than the target, increment `left` pointer
     - If sum is greater than the target, decrement `right` pointer
     - If sum equals the target, add the quadruplet and skip duplicates for both `left` and `right`

## Complexity

- **Time**: O(n³) - sorting takes O(n log n) and the nested loop with two-pointer approach takes O(n³)
- **Space**: O(1) - excluding the space for the output

## Solution Code

```go
package main

import (
	"sort"
)

func fourSum(nums []int, target int) [][]int {
	sort.Ints(nums)
	result := make([][]int, 0)
	n := len(nums)
	
	for i := 0; i < n-3; i++ {
		// Skip duplicate values for the first element
		if i > 0 && nums[i] == nums[i-1] {
			continue
		}
		
		for j := i + 1; j < n-2; j++ {
			// Skip duplicate values for the second element
			if j > i+1 && nums[j] == nums[j-1] {
				continue
			}
			
			left, right := j+1, n-1
			newTarget := target - nums[i] - nums[j]
			
			for left < right {
				sum := nums[left] + nums[right]
				if sum == newTarget {
					result = append(result, []int{nums[i], nums[j], nums[left], nums[right]})
					
					// Skip duplicates for the third element
					for left < right && nums[left] == nums[left+1] {
						left++
					}
					
					// Skip duplicates for the fourth element
					for left < right && nums[right] == nums[right-1] {
						right--
					}
					
					left++
					right--
				} else if sum < newTarget {
					left++
				} else {
					right--
				}
			}
		}
	}
	
	return result
}
```

## Link

[LeetCode 0018 4Sum](https://leetcode.com/problems/4sum/)