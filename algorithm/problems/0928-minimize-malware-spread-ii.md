# 0928 Minimize Malware Spread II

## Problem Description

You are given a network of `n` nodes represented as an `n x n` adjacency matrix `graph`, where `graph[i][j] = 1` means there is a direct connection between node `i` and node `j`, and `graph[i][j] = 0` means there is no direct connection.

A node `i` is directly infected by malware if `initial[i] == 1`. When a node is infected, all nodes connected to it (directly or indirectly) will also be infected.

Your task is to find the node in `initial` that, when removed, minimizes the number of nodes infected by malware. If multiple nodes have the same effect, return the node with the smallest index.

### Example 1:
```
Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
Output: 0
```

### Example 2:
```
Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
Output: 0
```

### Example 3:
```
Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
Output: 1
```

## Approach

This is a variant of the Minimize Malware Spread problem. The key difference is that we need to simulate removing each initially infected node and calculate the resulting infection spread.

1. **BFS/DFS for Infection Spread**: For each initially infected node, we need to simulate the infection spread when that node is removed.

2. **Simulation Process**:
   - For each node in `initial`, create a copy of the initially infected set without that node
   - Run BFS/DFS to simulate infection spread from the remaining infected nodes
   - Count the total number of infected nodes
   - Track which node removal results in the smallest infection

3. **Optimization**: Instead of running BFS from scratch for each removal, we can:
   - Find all connected components
   - For each component, track which initially infected nodes belong to it
   - If a component has exactly one initially infected node, removing that node will save the entire component

## Solution Code

```go
func minMalwareSpread(graph [][]int, initial []int) int {
    n := len(graph)
    parent := make([]int, n)
    
    // Initialize Union Find
    for i := range parent {
        parent[i] = i
    }
    
    var find func(x int) int
    find = func(x int) int {
        if parent[x] != x {
            parent[x] = find(parent[x])
        }
        return parent[x]
    }
    
    union := func(x, y int) {
        rootX, rootY := find(x), find(y)
        if rootX != rootY {
            parent[rootX] = rootY
        }
    }
    
    // Build connected components
    for i := 0; i < n; i++ {
        for j := 0; j < n; j++ {
            if graph[i][j] == 1 {
                union(i, j)
            }
        }
    }
    
    // Count nodes in each component
    componentSize := make(map[int]int)
    for i := 0; i < n; i++ {
        root := find(i)
        componentSize[root]++
    }
    
    // Count initially infected nodes in each component
    infectedCount := make(map[int]int)
    for _, node := range initial {
        root := find(node)
        infectedCount[root]++
    }
    
    // Find the best node to remove
    result := initial[0]
    maxSaved := -1
    
    for _, node := range initial {
        root := find(node)
        saved := 0
        if infectedCount[root] == 1 {
            saved = componentSize[root]
        }
        
        if saved > maxSaved || (saved == maxSaved && node < result) {
            maxSaved = saved
            result = node
        }
    }
    
    return result
}
```

## Complexity Analysis

- **Time**: O(n²α(n)) where n is the number of nodes and α is the inverse Ackermann function
  - Building the graph: O(n²)
  - Union Find operations: O(n²α(n)) but practically O(n²)
- **Space**: O(n) for the Union Find data structure and auxiliary maps

## Link

[LeetCode 0928 Minimize Malware Spread II](https://leetcode.com/problems/minimize-malware-spread-ii/)